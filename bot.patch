diff --git a/telegram_dnd_bot.py b/telegram_dnd_bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a160828a9d5d1da7b679421db5d0dfc261a48d3a
--- /dev/null
+++ b/telegram_dnd_bot.py
@@ -0,0 +1,387 @@
+"""Telegram bot: "–§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç, –±—Ä–æ—Å–∞—é—â–∞—è –∫—É–±—ã".
+
+Features:
+- /roll [formula] [var=value ...]
+- /roll Divination -> d20 prophecy mode
+- Persistent HP system for chat participants
+- /dmg <target>, /heal <target>, /resurrection <target>, /hp
+"""
+
+from __future__ import annotations
+
+import json
+import logging
+import os
+import random
+from dataclasses import dataclass
+from datetime import date, datetime
+from pathlib import Path
+from typing import Any
+
+from telegram import Update, User
+from telegram.ext import Application, CommandHandler, ContextTypes
+
+from dice_roll import roll_formula
+
+logging.basicConfig(
+    format="%(asctime)s | %(name)s | %(levelname)s | %(message)s",
+    level=logging.INFO,
+)
+LOGGER = logging.getLogger(__name__)
+
+STATE_PATH = Path("telegram_dnd_bot_state.json")
+MAX_HP = 100
+DAILY_LIMIT = 10
+WEEKLY_RESURRECTION_LIMIT = 1
+
+
+DIVINATION_LINES: dict[int, str] = {
+    1: "–Ω–µ –¥–µ–ª–∞–π —ç—Ç–æ–≥–æ ‚Äî —Ç—ã –±—É–∫–≤–∞–ª—å–Ω–æ —É–º—Ä—ë—à—å. –Ø –≤–∏–¥–µ–ª–∞ —ç—Ç–æ –≤ —Ç—Ä–µ—Å–Ω—É–≤—à–µ–º –∑–µ—Ä–∫–∞–ª–µ.",
+    2: "–º–∏—Ä —à–µ–ø—á–µ—Ç: ‚Äò—Å–µ–≥–æ–¥–Ω—è –Ω–µ —Ç–≤–æ–π –¥–µ–Ω—å‚Äô, –∏ –æ–Ω –æ–±—ã—á–Ω–æ –ø—Ä–∞–≤.",
+    3: "–ª—É—á—à–µ –æ—Ç–ª–æ–∂–∏. –°—É–¥—å–±–∞ —Å–ø–æ—Ç–∫–Ω—É–ª–∞—Å—å –æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–ª–∞—â.",
+    4: "–∏–¥–µ—è —Å–º–µ–ª–∞—è‚Ä¶ –∏ –æ–ø–∞—Å–Ω–∞—è. –ü–æ–¥–≥–æ—Ç–æ–≤—å –ø–ª–∞–Ω –ë –∏ –ø–ª–∞–Ω –°.",
+    5: "–º–æ–∂–µ—Ç —Å—Ä–∞–±–æ—Ç–∞—Ç—å, –µ—Å–ª–∏ —Å–Ω–∞—á–∞–ª–∞ –ø–æ–º–æ–ª–∏—Ç—å—Å—è –≤—Å–µ–º –∫—É–±–∏—á–µ—Å–∫–∏–º –±–æ–≥–∞–º.",
+    6: "—à–∞–Ω—Å—ã —Å–∫—Ä–æ–º–Ω—ã–µ, –Ω–æ —É–ø—Ä—è–º—Å—Ç–≤–æ –∏–Ω–æ–≥–¥–∞ —Ç–≤–æ—Ä–∏—Ç —á—É–¥–µ—Å–∞.",
+    7: "–≤ —Ç—É–º–∞–Ω–µ –≤–∏–∂—É ‚Äò–ø–æ—á—Ç–∏‚Äô. –ë—É–¥–µ—Ç –±–ª–∏–∑–∫–æ, –Ω–æ –Ω–µ –∏–¥–µ–∞–ª—å–Ω–æ.",
+    8: "–º–æ–∂–Ω–æ –ø—Ä–æ–±–æ–≤–∞—Ç—å, –Ω–æ —Å—É–¥—å–±–∞ —Å–µ–π—á–∞—Å –≤ –∏–≥—Ä–∏–≤–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏.",
+    9: "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –≤–µ—Ç–µ—Ä. –í—Å—ë –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–≤–æ–µ–π —Ö–∞—Ä–∏–∑–º—ã.",
+    10: "–≤ —Ü–µ–ª–æ–º –ø–æ–ª—É—á–∏—Ç—Å—è, –Ω–æ –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ: –ª–∏—à–Ω–∏–π —à–∞–≥ ‚Äî –∏ –±—É–¥–µ—Ç –¥—Ä–∞–º–∞.",
+    11: "—Å—Ä–µ–¥–Ω–µ-—Ö–æ—Ä–æ—à–æ. –ù–µ –ª–µ–≥–µ–Ω–¥–∞, –Ω–æ –¥–æ—Å—Ç–æ–π–Ω–æ.",
+    12: "–¥–∞, –µ—Å–ª–∏ –¥–µ–ª–∞—Ç—å —É–≤–µ—Ä–µ–Ω–Ω–æ –∏ –±–µ–∑ –ø–∞–Ω–∏–∫–∏.",
+    13: "–∑–≤—ë–∑–¥—ã –∫–∏–≤–∞—é—Ç. –ü–∞—Ö–Ω–µ—Ç —É—Å–ø–µ—Ö–æ–º.",
+    14: "–æ—á–µ–Ω—å –Ω–µ–ø–ª–æ—Ö–æ: —Ñ–æ—Ä—Ç—É–Ω–∞ —É–∂–µ –ø–æ–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ–±–µ –∫–æ—Ä–æ–Ω—É.",
+    15: "–¥–∞! –∏ –∫—Ä–∞—Å–∏–≤–æ. –° —ç—Ñ—Ñ–µ–∫—Ç–Ω—ã–º —Ä–∞–∑–≤–æ—Ä–æ—Ç–æ–º –ø–ª–∞—â–∞.",
+    16: "–æ—Ç–ª–∏—á–Ω—ã–π –∑–Ω–∞–∫. –£ —Å—É–¥—å–±—ã –Ω–∞ —Ç–µ–±—è –º—è–≥–∫–∏–π –≤–∑–≥–ª—è–¥.",
+    17: "–ø–æ—á—Ç–∏ —Ç—Ä–∏—É–º—Ñ. –ì–ª–∞–≤–Ω–æ–µ ‚Äî –Ω–µ —Å–≥–ª–∞–∑—å.",
+    18: "—Ç–≤–æ–π –º–æ–º–µ–Ω—Ç. –î–µ–ª–∞–π –∏ —Å–∏—è–π.",
+    19: "–≤–µ–ª–∏–∫–æ–ª–µ–ø–Ω–æ. –°–µ–≥–æ–¥–Ω—è —Ç—ã –≥–ª–∞–≤–Ω—ã–π –≥–µ—Ä–æ–π —ç—Ç–æ–π –≥–ª–∞–≤—ã.",
+    20: "–∞–±—Å–æ–ª—é—Ç–Ω–æ–µ ‚Äò–î–ê‚Äô. –°—É–¥—å–±–∞ –∞–ø–ª–æ–¥–∏—Ä—É–µ—Ç —Å—Ç–æ—è, –¥–∞–∂–µ –Ω–µ–º–Ω–æ–≥–æ –ø–ª–∞—á–µ—Ç.",
+}
+
+
+HELP_TEXT = (
+    "–Ø ‚Äî *–§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç, –±—Ä–æ—Å–∞—é—â–∞—è –∫—É–±—ã* üîÆüé≤\n"
+    "–¢–∞–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–∏–¥–∏—Ü–∞ –≤–∞—à–µ–π –ø–∞—Ä—Ç–∏–∏.\n\n"
+    "–ö–æ–º–∞–Ω–¥—ã:\n"
+    "‚Ä¢ `/roll` ‚Äî –±—Ä–æ—Å–∏—Ç—å d20\n"
+    "‚Ä¢ `/roll 2d6+3`\n"
+    "‚Ä¢ `/roll Divination` ‚Äî –ø—Ä–æ—Ä–æ—á–µ—Å—Ç–≤–æ –ø–æ d20\n"
+    "‚Ä¢ `/dmg <–Ω–∏–∫>` ‚Äî –Ω–∞–Ω–µ—Å—Ç–∏ 1d8 —É—Ä–æ–Ω–∞ (10 –∑–∞—Ä—è–¥–æ–≤/–¥–µ–Ω—å)\n"
+    "‚Ä¢ `/heal <–Ω–∏–∫>` ‚Äî –∏—Å—Ü–µ–ª–∏—Ç—å –Ω–∞ 1d8 (10 –∑–∞—Ä—è–¥–æ–≤/–¥–µ–Ω—å)\n"
+    "‚Ä¢ `/resurrection <–Ω–∏–∫>` ‚Äî –≤–µ—Ä–Ω—É—Ç—å –∫ 100 HP (1/–Ω–µ–¥–µ–ª—é)\n"
+    "‚Ä¢ `/hp` ‚Äî —Ç–≤–æ–∏ —Ç–µ–∫—É—â–∏–µ HP"
+)
+
+
+@dataclass
+class Target:
+    user_id: str
+    name: str
+
+
+def load_state() -> dict[str, Any]:
+    if not STATE_PATH.exists():
+        return {"players": {}, "usage": {}}
+
+    try:
+        payload = json.loads(STATE_PATH.read_text(encoding="utf-8"))
+    except (OSError, json.JSONDecodeError):
+        LOGGER.warning("Failed to load state, creating new state file")
+        return {"players": {}, "usage": {}}
+
+    payload.setdefault("players", {})
+    payload.setdefault("usage", {})
+    return payload
+
+
+def save_state(state: dict[str, Any]) -> None:
+    STATE_PATH.write_text(json.dumps(state, ensure_ascii=False, indent=2), encoding="utf-8")
+
+
+def user_display_name(user: User | None) -> str:
+    if not user:
+        return "–°—Ç—Ä–∞–Ω–Ω–∏—Ü–∞"
+    if user.full_name:
+        return user.full_name
+    if user.username:
+        return f"@{user.username}"
+    return str(user.id)
+
+
+def ensure_player(state: dict[str, Any], user_id: str, name: str) -> dict[str, Any]:
+    players = state["players"]
+    player = players.get(user_id)
+    if not player:
+        player = {"name": name, "hp": MAX_HP}
+        players[user_id] = player
+    else:
+        player["name"] = name
+        player.setdefault("hp", MAX_HP)
+    return player
+
+
+def current_day_key() -> str:
+    return date.today().isoformat()
+
+
+def current_week_key() -> str:
+    today = datetime.now().isocalendar()
+    return f"{today.year}-W{today.week:02d}"
+
+
+def actor_usage(state: dict[str, Any], actor_id: str) -> dict[str, Any]:
+    usage = state["usage"].setdefault(actor_id, {})
+
+    day_key = current_day_key()
+    if usage.get("day") != day_key:
+        usage["day"] = day_key
+        usage["dmg"] = 0
+        usage["heal"] = 0
+
+    week_key = current_week_key()
+    if usage.get("week") != week_key:
+        usage["week"] = week_key
+        usage["resurrection"] = 0
+
+    usage.setdefault("dmg", 0)
+    usage.setdefault("heal", 0)
+    usage.setdefault("resurrection", 0)
+    return usage
+
+
+def find_target_from_arg(state: dict[str, Any], raw_target: str) -> Target | None:
+    needle = raw_target.strip().lower().lstrip("@")
+    if not needle:
+        return None
+
+    for user_id, player in state["players"].items():
+        name = str(player.get("name", ""))
+        if name.lower().lstrip("@") == needle:
+            return Target(user_id=user_id, name=name)
+    return None
+
+
+def resolve_target(update: Update, context: ContextTypes.DEFAULT_TYPE, state: dict[str, Any]) -> Target | None:
+    if update.message and update.message.reply_to_message and update.message.reply_to_message.from_user:
+        target_user = update.message.reply_to_message.from_user
+        target_name = user_display_name(target_user)
+        ensure_player(state, str(target_user.id), target_name)
+        return Target(user_id=str(target_user.id), name=target_name)
+
+    if context.args:
+        matched = find_target_from_arg(state, context.args[0])
+        if matched:
+            return matched
+
+    return None
+
+
+async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    del context
+    if not update.message:
+        return
+
+    state = load_state()
+    current_name = user_display_name(update.effective_user)
+    ensure_player(state, str(update.effective_user.id), current_name)
+    save_state(state)
+
+    await update.message.reply_text(HELP_TEXT, parse_mode="Markdown")
+
+
+async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    await start(update, context)
+
+
+async def roll(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    if not update.message:
+        return
+
+    state = load_state()
+    author_name = user_display_name(update.effective_user)
+    ensure_player(state, str(update.effective_user.id), author_name)
+    save_state(state)
+
+    if context.args and context.args[0].lower() == "divination":
+        value = random.randint(1, 20)
+        prophecy = DIVINATION_LINES[value]
+        await update.message.reply_text(
+            f"üîÆ –§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç —Ä–∞—Å–∫—Ä—É—á–∏–≤–∞–µ—Ç –Ω–∏—Ç—å —Å—É–¥—å–±—ã... d20 = {value}\n"
+            f"{prophecy}"
+        )
+        return
+
+    formula = context.args[0] if context.args else "1d20"
+    vars_payload = parse_vars(context.args[1:]) if context.args else {}
+
+    try:
+        result = roll_formula(formula, **vars_payload)
+    except ValueError as exc:
+        await update.message.reply_text(
+            "üå´Ô∏è –¢—É–º–∞–Ω —Å–∫—Ä—ã–≤–∞–µ—Ç —Ñ–æ—Ä–º—É–ª—É. –ü–æ–ø—Ä–æ–±—É–π —Ç–∞–∫:\n"
+            "/roll, /roll 1d20+5, /roll 2–¥6+3, /roll ({str}+1)d20 str=3\n"
+            f"–û—à–∏–±–∫–∞: {exc}"
+        )
+        return
+
+    await update.message.reply_text(
+        f"üé≤ –§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç —à–µ–ø—á–µ—Ç: {author_name}, —Ç–≤–æ–π –±—Ä–æ—Å–æ–∫ {formula} = {result}"
+    )
+
+
+def parse_vars(tokens: list[str]) -> dict[str, Any]:
+    result: dict[str, Any] = {}
+    for token in tokens:
+        if "=" not in token:
+            continue
+        key, raw_value = token.split("=", 1)
+        key = key.strip()
+        raw_value = raw_value.strip()
+        if not key:
+            continue
+
+        try:
+            result[key] = int(raw_value)
+        except ValueError:
+            result[key] = raw_value
+    return result
+
+
+async def hp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    del context
+    if not update.message:
+        return
+
+    state = load_state()
+    actor_name = user_display_name(update.effective_user)
+    player = ensure_player(state, str(update.effective_user.id), actor_name)
+    save_state(state)
+
+    await update.message.reply_text(
+        f"üíó {actor_name}, —è –≤–∏–∂—É —Ç–≤–æ—é –∂–∏–∑–Ω–µ–Ω–Ω—É—é –Ω–∏—Ç—å: {player['hp']} HP."
+    )
+
+
+async def dmg(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    await apply_delta(update, context, mode="dmg")
+
+
+async def heal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    await apply_delta(update, context, mode="heal")
+
+
+async def apply_delta(update: Update, context: ContextTypes.DEFAULT_TYPE, mode: str) -> None:
+    if not update.message or not update.effective_user:
+        return
+
+    state = load_state()
+    actor_name = user_display_name(update.effective_user)
+    actor_id = str(update.effective_user.id)
+    ensure_player(state, actor_id, actor_name)
+
+    target = resolve_target(update, context, state)
+    if not target:
+        await update.message.reply_text(
+            "‚ú® –£–∫–∞–∂–∏ —Ü–µ–ª—å: `/dmg <–Ω–∏–∫>` –∏–ª–∏ `/heal <–Ω–∏–∫>`, "
+            "–ª–∏–±–æ –æ—Ç–≤–µ—Ç—å –∫–æ–º–∞–Ω–¥–æ–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω—É–∂–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞.",
+            parse_mode="Markdown",
+        )
+        save_state(state)
+        return
+
+    usage = actor_usage(state, actor_id)
+    if mode == "dmg" and usage["dmg"] >= DAILY_LIMIT:
+        await update.message.reply_text("üïØÔ∏è –ù–∞ —Å–µ–≥–æ–¥–Ω—è —Ç–≤–æ–∏ –∑–∞—Ä—è–¥—ã —É—Ä–æ–Ω–∞ –∏—Å—á–µ—Ä–ø–∞–Ω—ã (10/10).")
+        save_state(state)
+        return
+
+    if mode == "heal" and usage["heal"] >= DAILY_LIMIT:
+        await update.message.reply_text("üïØÔ∏è –ù–∞ —Å–µ–≥–æ–¥–Ω—è —Ç–≤–æ–∏ –∑–∞—Ä—è–¥—ã –ª–µ—á–µ–Ω–∏—è –∏—Å—á–µ—Ä–ø–∞–Ω—ã (10/10).")
+        save_state(state)
+        return
+
+    amount = random.randint(1, 8)
+    player = ensure_player(state, target.user_id, target.name)
+
+    if mode == "dmg":
+        usage["dmg"] += 1
+        player["hp"] = max(0, int(player["hp"]) - amount)
+        if player["hp"] == 0:
+            line = (
+                f"üí• –§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç –Ω–∞–Ω–æ—Å–∏—Ç {amount} —É—Ä–æ–Ω–∞ {player['name']}.\n"
+                "–ø—Ä–æ—Å—Ç–∏ —Ç—ã —É–º–µ—Ä–ª–∞"
+            )
+        else:
+            line = (
+                f"üí• –§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç –Ω–∞–Ω–æ—Å–∏—Ç {amount} —É—Ä–æ–Ω–∞ {player['name']}.\n"
+                f"–û—Å—Ç–∞–ª–æ—Å—å: {player['hp']} HP"
+            )
+    else:
+        usage["heal"] += 1
+        player["hp"] = min(MAX_HP, int(player["hp"]) + amount)
+        line = (
+            f"‚ú® –§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç –∏—Å—Ü–µ–ª—è–µ—Ç {player['name']} –Ω–∞ {amount} HP.\n"
+            f"–¢–µ–ø–µ—Ä—å: {player['hp']} HP"
+        )
+
+    save_state(state)
+    await update.message.reply_text(line)
+
+
+async def resurrection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    if not update.message or not update.effective_user:
+        return
+
+    state = load_state()
+    actor_id = str(update.effective_user.id)
+    actor_name = user_display_name(update.effective_user)
+    ensure_player(state, actor_id, actor_name)
+
+    target = resolve_target(update, context, state)
+    if not target:
+        await update.message.reply_text(
+            "üåô –£–∫–∞–∂–∏, –∫–æ–≥–æ –≤–æ—Å–∫—Ä–µ—à–∞—Ç—å: `/resurrection <–Ω–∏–∫>` "
+            "–∏–ª–∏ –æ—Ç–≤–µ—Ç—å –∫–æ–º–∞–Ω–¥–æ–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞.",
+            parse_mode="Markdown",
+        )
+        save_state(state)
+        return
+
+    usage = actor_usage(state, actor_id)
+    if usage["resurrection"] >= WEEKLY_RESURRECTION_LIMIT:
+        await update.message.reply_text("‚õî –ù–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ —É —Ç–µ–±—è —É–∂–µ –±—ã–ª —Ä–∏—Ç—É–∞–ª –≤–æ—Å–∫—Ä–µ—à–µ–Ω–∏—è (1/1).")
+        save_state(state)
+        return
+
+    usage["resurrection"] += 1
+    player = ensure_player(state, target.user_id, target.name)
+    player["hp"] = MAX_HP
+    save_state(state)
+
+    await update.message.reply_text(
+        f"üïäÔ∏è –§—ç–π—Ç –ê—Ä–¥–µ–Ω—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç {player['name']} –∏–∑-–∑–∞ –≥—Ä–∞–Ω–∏.\n"
+        f"–ñ–∏–∑–Ω—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {MAX_HP} HP."
+    )
+
+
+def main() -> None:
+    token = os.getenv("BOT_TOKEN")
+    if not token:
+        raise RuntimeError("BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω. –ü—Ä–∏–º–µ—Ä: export BOT_TOKEN='123:abc'")
+
+    application = Application.builder().token(token).build()
+    application.add_handler(CommandHandler("start", start))
+    application.add_handler(CommandHandler("help", help_command))
+    application.add_handler(CommandHandler("roll", roll))
+    application.add_handler(CommandHandler("hp", hp))
+    application.add_handler(CommandHandler("dmg", dmg))
+    application.add_handler(CommandHandler("heal", heal))
+    application.add_handler(CommandHandler("resurrection", resurrection))
+    application.add_handler(CommandHandler("Resurrection", resurrection))
+
+    LOGGER.info("Starting Telegram bot polling")
+    application.run_polling(close_loop=False)
+
+
+if __name__ == "__main__":
+    main()
